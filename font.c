/**
@brief Fonts
@author Stephan Ruloff
@date 01.07.2014
*/

/*
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; in version 2 only
of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include "font.h"

#define TAB_WIDTH 10 /* px */

FontMaster* FontCreate(void)
{
	FontMaster *m = NULL;
	
	m = (FontMaster*)malloc(sizeof(FontMaster));
	if (m) {
		memset(m, 0, sizeof(FontMaster));
	}
	
	return m;
}

uint8_t FontLoad(FontMaster *m, const char *filename)
{
	FILE *f;
	uint8_t x = 0;
	uint8_t y = 0;
	char ch;
	uint32_t symbol;
	int c;
	int symbolX;
	int symbolY;
	FontData data;
	int ret;
	uint8_t anz = 0;
	uint16_t size;
	uint16_t pos;
	int i;
	uint32_t line = 1;
	uint8_t quit = 0;
	
	if (m == NULL) {
		return 0;
	}
	f = fopen(filename, "rb");
	if (f == NULL) {
		return 0;
	}
	
	while (!feof(f) && !quit) {
		memset(&data, 0, sizeof(data));
		c = fgetc(f);
		if (c != EOF && (c < '0' || c > '9')) {
			printf("No Header found in line %i\n", line);
			break;
		}
		if (c == EOF) {
			break;
		}
		fseek(f, -1, SEEK_CUR);
		ret = fscanf(f, "%dx%d %X", &symbolX, &symbolY, &symbol);
		if ((ret != -1 && ret != 3) || symbol > 255) {
			printf("Header-Erorr in line %i\n", line);
			break;
		}
		if (ret == EOF) {
			// File-end
			break;
		}
		//printf("%i %i %c\n", symbolX, symbolY, symbol);
		anz++;
		data.mX = symbolX;
		data.mY = symbolY;
		size = data.mX * data.mY;
		data.mData = (uint8_t*)malloc(size);
		if (data.mData == NULL) {
			return 0;
		}
		memset(data.mData, 0, size);
		y = 0;
		x = 0;
		c = fgetc(f);
		if (c != '\n') {
			break;
		}
		line++;
		while (!feof(f)) {
			c = fgetc(f);
			if (c == EOF) {
				break;
			}
			ch = (char)c;
			//printf("%i\n", c);
			if (ch != ' ' && ch != '\r' && ch != '\n') {
				if (x < (data.mX) && y < (data.mY)) {
					pos = (y * data.mX) + x;
					data.mData[pos] = 1;
					//printf("pos: %i\n", pos);
					//printf("%i %i %i\n", x, y, ch);
				} else {
					printf("Data error in line %i\n", line);
					quit = 1;
					break;
				}
			} else if (ch == ' ') {
				if (x >= (data.mX) || y >= (data.mY)) {
					printf("Data error in line %i\n", line);
					quit = 1;
					break;
				}
			} else if (ch == '\n') {
				y++;
				line++;
				x = 255;
				if (y >= data.mY) {
					break;
				}
			}
			x++;
		}
		//printf("%2ix%2i %02X\n", data.mX, data.mY, symbol);
		m->mChars[(int)symbol] = data;
	}
	fclose(f);
	
	// add a "standard" character to all unset positions
	for (i = 0; i < 256; i++) {
		//printf("%i %p %p %p\n", i, m, &m->mChars[i], m->mChars[i].mData);
		if (!m->mChars[i].mData) {
			m->mChars[i].mX = 1;
			m->mChars[i].mY = 8;
			m->mChars[i].mData = (uint8_t*)calloc(8, 1);
		}
	}
	
	return anz;
}

void FontDestroy(FontMaster *m)
{
	int i;
	
	if (m == NULL) {
		return;
	}
	for (i = 0; i < 256; i++) {
		if (m->mChars[i].mData) {
			free(m->mChars[i].mData);
		}
	}
	free(m);
}

void FontDebugPrint(FontMaster *m, char c)
{
	uint8_t x;
	uint8_t y;
	FontData d;
	
	if (m == NULL) {
		return;
	}
	d = m->mChars[(int)c];
	if (d.mX == 0 || d.mY == 0) {
		return;
	}
	printf("%c, %ix%i\n", c, d.mX, d.mY);
	for (y = 0; y < d.mY; y++) {
		for (x = 0; x < d.mX; x++) {
			if (d.mData[(y * d.mX) + x]) { 
				putchar('*');
			} else {
				putchar(' ');
			}
		}
		printf("\n");
	}
}

/**
@retval 0 Ok
@retval 1 Param error
@retval 2 No file
*/
int FontConvertToHeader(FontMaster *m, const char *fontname, const char *headername)
{
	uint8_t x;
	uint8_t y;
	FontData d;
	FILE *f;
	int i;
	int cnt = 0;
	
	if (m == NULL || !fontname || !headername) {
		return 1;
	}
	f = fopen(headername, "w");
	if (!f) {
		return 2;
	}
	fprintf(f, "#ifndef _%s_H_\n", fontname);
	fprintf(f, "#define _%s_H_\n\n", fontname);
	fprintf(f, "/* autogenerated by FontConvert, do not touch !! */\n\n");
	
	fprintf(f, "#include <stdint.h>\n\n");
	fprintf(f, "/* data */\n");
	for (i = 0; i < 256; i++) {
		d = m->mChars[i];
		if (d.mX == 0 || d.mY == 0) {
			return 3;
		}
		cnt = 0;
		//printf("%ix%i\n", d.mX, d.mY);
		fprintf(f, "static uint8_t sData_%s_%02X[] = {\n", fontname, i);
		for (y = 0; y < d.mY; y++) {
			cnt = 0;
			for (x = 0; x < d.mX; x++) {
				if (cnt) {
					fprintf(f,", ");
				}
				fprintf(f, "%02X", d.mData[(y * d.mX) + x]);
				cnt++;
			}
			if (y < (d.mY - 1)) {
				fprintf(f, ", \n");
			} else {
				fprintf(f, "\n");
			}
		}
		fprintf(f, "};\n");
	}
	
	fprintf(f, "/* font */\n");
	fprintf(f, "FontMaster %s = {{\n", fontname);
	for (i = 0; i < 256; i++) {
		d = m->mChars[i];
		if (d.mX == 0 || d.mY == 0) {
			return 4;
		}
		//printf("%02X, %ix%i\n", i, d.mX, d.mY);
		fprintf(f, "\t{ %i, %i, sData_%s_%02X }", d.mX, d.mY, fontname, i);
		if (i < 255) {
			fprintf(f, ",\n");
		} else {
			fprintf(f, "\n");
		}
		
	}
	fprintf(f, "}};\n");
	fprintf(f, "#endif\n");
	fclose(f);
	
	return 0;
}

uint16_t FontStringX(FontMaster *m, const char *text)
{
	uint16_t len = 0;
	uint32_t l;
	uint32_t i;

	if (text == NULL || m == NULL) {
		return 0;
	}
	l = strlen(text);
	for (i = 0; i < l; i++) {
		if (i) {
			len++; // character spacing
		}
		len += m->mChars[(int)text[i]].mX;
	}

	return len;
}

uint16_t FontStringY(FontMaster *m, const char *text)
{
	uint16_t max = 0;
	uint32_t l;
	uint32_t i;

	if (text == NULL || m == NULL) {
		return 0;
	}
	l = strlen(text);
	for (i = 0; i < l; i++) {
		if (max < m->mChars[(int)text[i]].mY) {
			max = m->mChars[(int)text[i]].mY;
		}
	}

	return max;
}

uint16_t FontCharX(FontMaster *m, char ch)
{
	if (m == NULL) {
		return 0;
	}
	return m->mChars[(int)ch].mX;
}

uint16_t FontCharY(FontMaster *m, char ch)
{
	if (m == NULL) {
		return 0;
	}
	return m->mChars[(int)ch].mY;
}

uint8_t FontScreenStringVp(FontMaster *m, ScreenData *screen, Rect viewPort, 
		const char *text, uint8_t isInv, uint8_t justify)
{
	uint8_t txtX;
	uint8_t txtY;
	ScreenData scr;
	
	if (viewPort.mX + viewPort.mWidth > screen->mX) {
		return 0;
	}
	if (viewPort.mY + viewPort.mHeight > screen->mY) {
		return 0;
	}
	// Here is only the X,Y and the Data-Pointer copied.
	// not the content !
	// but we only want to change the screen-settings
	scr = *screen;
	scr.mX = viewPort.mWidth + viewPort.mX;
	scr.mY = viewPort.mHeight + viewPort.mY;
	txtX = viewPort.mX;
	txtY = viewPort.mY;
	//printf("%i %i (%i %i)\n", txtX, txtY, scr.mX, scr.mY);
	
	return FontScreenString(m, &scr, txtX, txtY, text, isInv, justify);
}

uint8_t FontScreenString(FontMaster *m, ScreenData *screen, uint8_t txtX, 
		uint8_t txtY, const char *text, uint8_t isInv, uint8_t justify)
{
	uint32_t i;
	uint32_t l;
	uint8_t x;
	uint8_t y;
	FontData d;
	int32_t start = 0;
	uint8_t value;
	uint32_t pos;
	uint32_t lenOutput;
	uint16_t fontHeight;
	uint8_t noSpace = 0;
	
	if (m == NULL || screen == NULL || text == NULL) {
		return 0;
	}
	l = strlen(text);
	lenOutput = FontStringX(m, text);
	fontHeight = FontStringY(m, text);
	if (justify == JUSTIFY_CENTER) {
		start -= lenOutput / 2;
	}
	for (i = 0; i < l; i++) {
		if (!noSpace && i && start + 1 < (screen->mX - txtX)) {
			for (y = 0; y < fontHeight; y++) {
				value = isInv ? 1 : 0;
				pos = ((y + txtY) * screen->mX) + start + txtX;
				if (pos < (screen->mX * screen->mY)) {
					screen->mData[pos] = value;
				}
			}
			start += 1;
		}
		noSpace = 0;
		d = m->mChars[(int)text[i]];
		if (text[i] == '\\' && ((i + 1) < l)) {
			if (text[i + 1] == 'n')	{
				// next line
				txtY += fontHeight + 1;
				start = 0;
				i += 1;
				noSpace = 1;
				//d = m->mChars[(int)text[i]];
				continue;
			}
			if (text[i + 1] == '\\') {
				d = m->mChars[(int)'\\'];
				i += 2;
			}
			if (text[i + 1] == 't') {
				start += TAB_WIDTH - ((start + TAB_WIDTH) % TAB_WIDTH);
				i += 1;
				noSpace = 1;
				//d = m->mChars[(int)text[i]];
				continue;
			}
		}
		if (start + d.mX > (screen->mX - txtX)) {
			// next line
			txtY += fontHeight + 1;
			start = 0;
		}
		for (y = 0; y < d.mY; y++) {
			for (x = 0; x < d.mX; x++) {
				if (d.mData[(y * d.mX) + x]) {
					value = isInv ? 0 : 1;
				} else {
					value = isInv ? 1 : 0;
				}
				pos = ((y + txtY) * screen->mX) + x + start + txtX;
				if (pos < (screen->mX * screen->mY)) {
					screen->mData[pos] = value;
				} else {
					//printf("Out: '%c'\n", text[i]);
				}
			}
		}
		start += d.mX;
	}
	
	return i;
}
